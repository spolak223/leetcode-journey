# My Thought Process
- Instantly I recognised this problem will require a stack due to keeping track of one bracket and then the other instance of it, reminding me of how a stack is used for RPN calculations
- So I created a dictionary which maps each bracket to their open and closed forms.
- Then the for loop iterates through the user input and when it finds a closed bracket, it checks the stack to see if the last element is its matching open bracket. If not, then I knew I can return False as this meant the entered string of brackets was invalid.
- Otherwise I would pop the open bracket from the stack and hopefully end up with an empty stack.
- Finally, if the bracket wasn't a closing bracket, it would just add the open bracket onto the stack ready for the next character.

- This was a simpler solution for me, was able to solve it relatively quickly. I was also able to optimize it by just returning "not stack" depending on if the stack was empty or not. This was much faster than iterating through the stack to see if it was empty or had values inside. 

# My Solution
[Link to my LeetCode Solution](https://leetcode.com/problems/valid-parentheses/submissions/1757125709/)
